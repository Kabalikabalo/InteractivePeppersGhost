<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>micro:bit Servo Controller</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <h1>micro:bit Servo Controller</h1>

  <button id="connect">Connect micro:bit</button>

  <div style="margin-top:1rem;">
    <input id="angle" type="number" min="0" max="180" value="90" />
    <button id="send">Send Angle</button>
  </div>

  <div style="margin-top:1rem;">
    <input id="slider" type="range" min="0" max="180" value="90" />
    <span id="val">90</span>Â°
  </div>

    <script>
    const UART_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_RX_CHAR = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

    let device = null;
    let server = null;
    let rxChar = null;

    async function requestOrReuseDevice() {
        if (device) return device;
        device = await navigator.bluetooth.requestDevice({
        // Using acceptAllDevices avoids requiring the UUID in the advert
        acceptAllDevices: true,
        // If you prefer, you can add namePrefix to narrow results:
        // filters: [{ namePrefix: 'BBC micro:bit' }, { namePrefix: 'micro:bit' }],
        optionalServices: [UART_SERVICE]
        });
        device.addEventListener('gattserverdisconnected', onDisconnected);
        return device;
    }

    async function connectGattWithRetry(maxRetries = 3) {
        let lastErr;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            if (!device.gatt.connected) {
            server = await device.gatt.connect();
            }
            const service = await server.getPrimaryService(UART_SERVICE);
            rxChar = await service.getCharacteristic(UART_RX_CHAR);
            return; // success
        } catch (e) {
            lastErr = e;
            // Small backoff before retrying
            await new Promise(r => setTimeout(r, 300 * attempt));
        }
        }
        throw lastErr;
    }

    async function connectFlow() {
        if (!('bluetooth' in navigator)) {
        alert('Web Bluetooth not supported on this browser/device.');
        return;
        }
        try {
        await requestOrReuseDevice();
        await connectGattWithRetry(3);
        alert('Connected!');
        } catch (e) {
        console.error('Connect failed:', e);
        alert('Connect failed: ' + (e?.message || e));
        }
    }

    function onDisconnected() {
        console.log('GATT disconnected');
        rxChar = null;
        // Optional: try to silently reconnect once
        connectGattWithRetry(2).catch(err => {
        console.warn('Auto-reconnect failed:', err);
        });
    }

    async function sendAngle(angle) {
        if (!rxChar) {
        alert('Not connected yet.');
        return;
        }
        try {
        angle = Math.max(0, Math.min(180, Number(angle) | 0));
        const data = new TextEncoder().encode(angle + '\n');
        await rxChar.writeValue(data);
        } catch (e) {
        console.error('Write failed:', e);
        alert('Write failed: ' + (e?.message || e));
        }
    }

    document.getElementById('connect').addEventListener('click', connectFlow);

    document.getElementById('send').addEventListener('click', () => {
        sendAngle(document.getElementById('angle').value);
    });

    const slider = document.getElementById('slider');
    const val = document.getElementById('val');
    slider.addEventListener('input', () => {
        val.textContent = slider.value;
        sendAngle(slider.value); // live send
        document.getElementById('angle').value = slider.value;
    });
    </script>

</body>
</html>
