<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Face → Servo (micro:bit)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0}
    body{display:grid;place-items:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;padding:16px}
    .wrap{display:flex;flex-direction:column;gap:12px;max-width:700px;width:100%}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button,input,select,label{font-size:1rem}
    #status{font-family:ui-monospace,Menlo,Consolas,monospace;color:#444;white-space:pre-line}
    video{position:absolute;opacity:0;width:1px;height:1px;pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Face → Servo (micro:bit)</h1>

    <div class="row">
      <button id="startCam">Start Camera</button>
      <button id="connectBt">Connect micro:bit</button>
      <button id="centerBtn">Center (90°)</button>
      <label><input type="checkbox" id="invertChk"> Invert direction</label>
      <label>Tracking
        <select id="mode">
          <option value="on" selected>On</option>
          <option value="hold">Hold (don't send)</option>
        </select>
      </label>
    </div>

    <div class="row">
      <label>Gain
        <input id="gain" type="range" min="10" max="90" value="60" />
        <span id="gainVal">60</span>°
      </label>
      <label>Dead-zone
        <input id="dead" type="range" min="1" max="20" value="6" />
        <span id="deadVal">6%</span>
      </label>
      <label>Smoothing
        <input id="smooth" type="range" min="0" max="95" value="70" />
        <span id="smoothVal">0.70</span>
      </label>
    </div>

    <div class="row">
      <label>Min <input id="amin" type="number" value="30" min="0" max="180" style="width:80px"></label>
      <label>Max <input id="amax" type="number" value="150" min="0" max="180" style="width:80px"></label>
      <label>Send every <input id="rate" type="number" value="1000" min="40" max="500" style="width:80px"> ms</label>
    </div>

    <pre id="status">Ready.</pre>
    <video id="video" autoplay playsinline muted></video>
  </div>

  <!-- ES modules version of MediaPipe Tasks Vision -->
  <script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9";

    // --- UI elements
    const video = document.getElementById('video');
    const startCamBtn = document.getElementById('startCam');
    const connectBtBtn = document.getElementById('connectBt');
    const centerBtn = document.getElementById('centerBtn');
    const invertChk = document.getElementById('invertChk');
    const modeSel = document.getElementById('mode');
    const gainInput = document.getElementById('gain'); const gainVal = document.getElementById('gainVal');
    const deadInput = document.getElementById('dead'); const deadVal = document.getElementById('deadVal');
    const smoothInput = document.getElementById('smooth'); const smoothVal = document.getElementById('smoothVal');
    const minInput = document.getElementById('amin'); const maxInput = document.getElementById('amax');
    const rateInput = document.getElementById('rate');
    const statusEl = document.getElementById('status');

    const log = (...a)=>{ statusEl.textContent = a.join(' ') + "\\n" + statusEl.textContent.split("\\n").slice(0,8).join("\\n"); };
    const clamp = (n, lo, hi)=>Math.max(lo, Math.min(hi, n));

    // reflect sliders
    gainInput.oninput = ()=> gainVal.textContent = gainInput.value;
    deadInput.oninput = ()=> deadVal.textContent = deadInput.value + '%';
    smoothInput.oninput = ()=> smoothVal.textContent = (Number(smoothInput.value)/100).toFixed(2);

    // --- Face tracking
    let landmarker = null, running = false;
    let emaX = 0;           // smoothed horizontal offset (-1 .. +1)
    let neutral = 0;        // recenter offset

    startCamBtn.onclick = async()=>{
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video:{facingMode:'user', width:{ideal:1280}, height:{ideal:720}}, audio:false
        });
        video.srcObject = stream; await video.play();

        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
        );
        // if your network blocks GCS, download this file next to your page and change to "./face_landmarker.task"
        const modelAssetPath = "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task";

        landmarker = await FaceLandmarker.createFromOptions(fileset, {
          baseOptions: { modelAssetPath },
          runningMode: "VIDEO",
          numFaces: 1
        });

        running = true;
        requestAnimationFrame(loop);
        log("Camera+Landmarker running…");
      }catch(e){ alert(e.message || e); }
    };

    function faceToAngle(xNorm){
      // xNorm: -1 (left) .. +1 (right) — from landmarks average
      const k = Number(smoothInput.value)/100; // 0..0.95
      emaX = (1-k)*xNorm + k*emaX;

      const err = (emaX - neutral) * (invertChk.checked ? -1 : 1);
      const dead = Number(deadInput.value)/100;
      const mag = Math.max(0, Math.abs(err) - dead) / (1 - dead); // 0..1 after dead-zone
      const signed = Math.sign(err) * mag;

      const gain = Number(gainInput.value);      // degrees from center at full deflection
      const minA = Number(minInput.value);
      const maxA = Number(maxInput.value);
      const angle = clamp(Math.round(90 + signed * gain), minA, maxA);
      return angle;
    }

    async function loop(){
      if (!running) return;
      try{
        const res = landmarker.detectForVideo(video, performance.now());
        if (res?.faceLandmarks?.length){
          // average x of all landmarks gives a robust face center
          const l = res.faceLandmarks[0];
          let x=0; for (let i=0;i<l.length;i++) x += l[i].x; x /= l.length;  // 0..1
          const xNorm = (x - 0.5)*2; // -1..+1
          const angle = faceToAngle(xNorm);
          if (modeSel.value === 'on') sendAngle(angle);
          uiAngle(angle);
        }else{
          // no face: relax toward center and don't spam writes
          emaX *= 0.98;
        }
      }catch(e){ /* ignore transient */ }
      requestAnimationFrame(loop);
    }

    function uiAngle(a){
      // quick little status line
      statusEl.textContent = `angle ${a}°, tracking=${modeSel.value}, invert=${invertChk.checked}`;
    }

    centerBtn.onclick = ()=>{ neutral = emaX; lastSentAngle = null; sendAngle(90); };

    // --- Bluetooth (Nordic UART on micro:bit)
    const NUS_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    let device=null, server=null, writableChar=null;
    let lastSentAngle = null;
    let lastWriteTs = 0;

    connectBtBtn.onclick = async()=>{
      try{
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix:'BBC micro:bit' }, { namePrefix:'micro:bit' }],
          optionalServices: [NUS_UUID]
        });
        device.addEventListener('gattserverdisconnected', ()=>{ writableChar=null; log('BT: disconnected'); });
        server = await device.gatt.connect();
        const svc = await server.getPrimaryService(NUS_UUID);
        const chars = await svc.getCharacteristics();
        writableChar = chars.find(c => c.properties.write || c.properties.writeWithoutResponse) || null;
        if (!writableChar){
          const dump = await Promise.all(chars.map(async c=>{
            const p=c.properties; return `${c.uuid} -> write:${!!p.write} wwr:${!!p.writeWithoutResponse}`;
          }));
          throw new Error('No writable char in NUS:\\n'+dump.join('\\n'));
        }
        log('BT: connected (char '+writableChar.uuid+')');
      }catch(e){ alert(e.message || e); }
    };

    async function sendAngle(angle){
      if (!writableChar || !device?.gatt?.connected) return;
      if (lastSentAngle !== null && Math.abs(angle - lastSentAngle) < 1) return; // ignore tiny changes
      const now = performance.now();
      const interval = clamp(Number(rateInput.value)|0, 40, 500);
      if (now - lastWriteTs < interval) return;  // throttle writes
      lastWriteTs = now;

      const payload = new TextEncoder().encode(String(angle) + "\\n");
      try{
        if (writableChar.properties.writeWithoutResponse && writableChar.writeValueWithoutResponse){
          await writableChar.writeValueWithoutResponse(payload);
        } else {
          await writableChar.writeValue(payload);
        }
        lastSentAngle = angle;
      }catch(e){ log('BT write error: '+(e.message||e)); }
    }
  </script>
</body>
</html>
