<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Face → Servo (with logging)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0}
    body{display:grid;place-items:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;padding:16px}
    .wrap{display:flex;flex-direction:column;gap:12px;max-width:800px;width:100%}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button,input,select,label{font-size:1rem}
    #status{font-family:ui-monospace,Menlo,Consolas,monospace;color:#333;white-space:pre-line}
    #last{font-family:ui-monospace,Menlo,Consolas,monospace;color:#111}
    #log{border:1px solid #ddd;border-radius:8px;padding:10px;height:180px;overflow:auto;background:#fafafa;font-family:ui-monospace,monospace;font-size:.95rem}
    video{position:absolute;opacity:0;width:1px;height:1px;pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Face → Servo (micro:bit) — with Logging</h1>

    <div class="row">
      <button id="startCam">Start Camera</button>
      <button id="connectBt">Connect micro:bit</button>
      <button id="centerBtn">Center (90°)</button>
      <label><input type="checkbox" id="invertChk"> Invert direction</label>
      <label>Tracking
        <select id="mode">
          <option value="on" selected>On</option>
          <option value="hold">Hold (don’t send)</option>
        </select>
      </label>
    </div>

    <div class="row">
      <label>Gain
        <input id="gain" type="range" min="10" max="90" value="60" />
        <span id="gainVal">60</span>°
      </label>
      <label>Dead-zone
        <input id="dead" type="range" min="1" max="20" value="6" />
        <span id="deadVal">6%</span>
      </label>
      <label>Smoothing
        <input id="smooth" type="range" min="0" max="95" value="70" />
        <span id="smoothVal">0.70</span>
      </label>
      <label>Min <input id="amin" type="number" value="30" min="0" max="180" style="width:80px"></label>
      <label>Max <input id="amax" type="number" value="150" min="0" max="180" style="width:80px"></label>
      <label>Send every <input id="rate" type="number" value="100" min="40" max="1000" style="width:80px"> ms</label>
    </div>

    <div class="row">
      <label>Manual angle <input id="manualAngle" type="number" min="0" max="180" value="90" style="width:80px"></label>
      <button id="sendManual">Send now</button>
      <button id="clearLog">Clear log</button>
    </div>

    <div id="last">Last event: (none)</div>
    <pre id="status">Ready.</pre>
    <div id="log"></div>

    <!-- hidden camera feed -->
    <video id="video" autoplay playsinline muted></video>
  </div>

  <!-- ES modules version of MediaPipe Tasks Vision -->
  <script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9";

    // --- UI refs
    const video = document.getElementById('video');
    const startCamBtn = document.getElementById('startCam');
    const connectBtBtn = document.getElementById('connectBt');
    const centerBtn = document.getElementById('centerBtn');
    const invertChk = document.getElementById('invertChk');
    const modeSel = document.getElementById('mode');
    const gainInput = document.getElementById('gain'); const gainVal = document.getElementById('gainVal');
    const deadInput = document.getElementById('dead'); const deadVal = document.getElementById('deadVal');
    const smoothInput = document.getElementById('smooth'); const smoothVal = document.getElementById('smoothVal');
    const minInput = document.getElementById('amin'); const maxInput = document.getElementById('amax');
    const rateInput = document.getElementById('rate');
    const statusEl = document.getElementById('status');
    const lastEl = document.getElementById('last');
    const logEl = document.getElementById('log');
    const manualAngle = document.getElementById('manualAngle');
    const sendManualBtn = document.getElementById('sendManual');
    const clearLogBtn = document.getElementById('clearLog');

    // --- helpers
    const clamp = (n, lo, hi)=>Math.max(lo, Math.min(hi, n));
    const nowStr = ()=> new Date().toLocaleTimeString();
    const logLines = [];
    function addLog(line){
      const s = `[${nowStr()}] ${line}`;
      logLines.push(s); if (logLines.length>300) logLines.shift();
      logEl.textContent = logLines.join('\n');
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setLast(text){ lastEl.textContent = `Last event: ${text}`; }
    const logStatus = (...a)=>{ statusEl.textContent = a.join(' ') + "\n" + statusEl.textContent.split("\n").slice(0,8).join("\n"); };

    // reflect sliders
    gainInput.oninput = ()=> gainVal.textContent = gainInput.value;
    deadInput.oninput = ()=> deadVal.textContent = deadInput.value + '%';
    smoothInput.oninput = ()=> smoothVal.textContent = (Number(smoothInput.value)/100).toFixed(2);

    // --- Face tracking → angle
    let landmarker = null, running = false;
    let emaX = 0, neutral = 0;       // normalized x tracking

    startCamBtn.onclick = async()=>{
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          video:{facingMode:'user', width:{ideal:1280}, height:{ideal:720}}, audio:false
        });
        video.srcObject = stream; await video.play();

        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
        );
        const modelAssetPath =
          "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task";

        landmarker = await FaceLandmarker.createFromOptions(fileset, {
          baseOptions: { modelAssetPath },
          runningMode: "VIDEO",
          numFaces: 1
        });

        running = true;
        requestAnimationFrame(loop);
        logStatus("Camera+Landmarker running…");
      }catch(e){ alert(e.message || e); }
    };

    function faceToAngle(xNorm){
      // xNorm: -1 .. +1 (left..right)
      const k = Number(smoothInput.value)/100; // 0..0.95
      emaX = (1-k)*xNorm + k*emaX;

      const err = (emaX - neutral) * (invertChk.checked ? -1 : 1);
      const dead = Number(deadInput.value)/100;
      const mag = Math.max(0, Math.abs(err) - dead) / (1 - dead);
      const signed = Math.sign(err) * mag;

      const gain = Number(gainInput.value);
      const minA = Number(minInput.value);
      const maxA = Number(maxInput.value);
      return clamp(Math.round(90 + signed * gain), minA, maxA);
    }

    let currentAngle = 90; // for logs
    async function loop(){
      if (!running) return;
      try{
        const res = landmarker.detectForVideo(video, performance.now());
        if (res?.faceLandmarks?.length){
          const l = res.faceLandmarks[0];
          let x=0; for (let i=0;i<l.length;i++) x += l[i].x; x/=l.length;
          currentAngle = faceToAngle((x-0.5)*2);
          if (modeSel.value === 'on') sendAngle(currentAngle, {reason:'auto'});
          statusEl.textContent = `tracking=${modeSel.value}  angle=${currentAngle}°  invert=${invertChk.checked}`;
        } else {
          emaX *= 0.98; // relax toward center slowly
          statusEl.textContent = `no face  tracking=${modeSel.value}`;
        }
      }catch{}
      requestAnimationFrame(loop);
    }

    centerBtn.onclick = ()=>{ neutral = emaX; lastSentAngle = null; sendAngle(90, {reason:'center', force:true}); };

    // --- Bluetooth (NUS)
    const NUS_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    let device=null, server=null, writableChar=null;
    let lastSentAngle = null;
    let lastWriteTs = 0;

    connectBtBtn.onclick = async()=>{
      try{
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix:'BBC micro:bit' }, { namePrefix:'micro:bit' }],
          optionalServices: [NUS_UUID]
        });
        device.addEventListener('gattserverdisconnected', ()=>{
          writableChar=null; addLog('BT: disconnected');
        });
        server = await device.gatt.connect();
        const svc = await server.getPrimaryService(NUS_UUID);
        const chars = await svc.getCharacteristics();
        writableChar = chars.find(c => c.properties.write || c.properties.writeWithoutResponse) || null;
        if (!writableChar){
          const dump = await Promise.all(chars.map(async c=>{
            const p=c.properties; return `${c.uuid} -> write:${!!p.write} wwr:${!!p.writeWithoutResponse}`;
          }));
          throw new Error('No writable char in NUS:\n'+dump.join('\n'));
        }
        addLog('BT: connected (char '+writableChar.uuid+')');
      }catch(e){ alert(e.message || e); }
    };

    sendManualBtn.onclick = ()=> {
      const a = clamp(Number(manualAngle.value)|0, 0, 180);
      manualAngle.value = String(a);
      sendAngle(a, {force:true, reason:'manual'});
    };
    clearLogBtn.onclick = ()=>{ logLines.length=0; logEl.textContent=''; setLast('(none)'); };

    // --- sending + instrumentation
    let periodAttempts = 0, periodSent = 0, periodSkipped = 0, lastReason = '(none)';
    function snapshotLog(){
      const connected = !!(device?.gatt?.connected);
      addLog(`snapshot: connected=${connected} wanted=${currentAngle}°  lastSent=${lastSentAngle ?? '—'}  lastReason=${lastReason}  rate=${rateInput.value}ms  sent=${periodSent} skipped=${periodSkipped} attempts=${periodAttempts}`);
      periodAttempts = periodSent = periodSkipped = 0;
    }
    setInterval(snapshotLog, 1000); // <-- log every 1000ms

    async function sendAngle(angle, {force=false, reason='auto'} = {}){
      periodAttempts++;
      if (!writableChar || !device?.gatt?.connected){
        periodSkipped++; lastReason = 'skip: not connected';
        setLast(`SKIP (not connected) angle=${angle}° [${reason}]`);
        return;
      }

      const now = performance.now();
      const interval = clamp(Number(rateInput.value)|0, 40, 1000);
      if (!force && now - lastWriteTs < interval){
        periodSkipped++; lastReason = 'skip: throttle';
        setLast(`SKIP (throttle) angle=${angle}° [${reason}]`);
        return;
      }
      if (!force && lastSentAngle !== null && Math.abs(angle - lastSentAngle) < 1){
        periodSkipped++; lastReason = 'skip: unchanged';
        setLast(`SKIP (unchanged) angle=${angle}° [${reason}]`);
        return;
      }

      const payload = new TextEncoder().encode(String(angle) + "\n");
      try{
        if (writableChar.properties.writeWithoutResponse && writableChar.writeValueWithoutResponse){
          await writableChar.writeValueWithoutResponse(payload);
        } else {
          await writableChar.writeValue(payload);
        }
        lastWriteTs = now;
        lastSentAngle = angle;
        periodSent++; lastReason = 'sent';
        const msg = `SENT angle=${angle}° [${reason}]`;
        setLast(msg); addLog(msg);
      }catch(e){
        periodSkipped++; lastReason = `error: ${e.message||e}`;
        const msg = `ERROR sending angle=${angle}° → ${e.message||e}`;
        setLast(msg); addLog(msg);
      }
    }
  </script>
</body>
</html>
