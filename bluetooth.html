<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Face Center Arrow</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --fg: #111; --muted:#666; --ok:#0a0; --warn:#c70; }
    html,body { height:100%; margin:0; }
    body { display:grid; place-items:center; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:10px; padding:20px; }
    h1 { margin:0 0 6px; font-size:1.2rem; color:var(--fg); }
    .row { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; align-items:center; }
    button, input { font-size:1rem; }
    #arrow {
      font-size: 96px; line-height:1; user-select:none;
      transition: transform .08s linear, color .15s ease, opacity .15s ease;
      color: var(--fg);
    }
    #arrow.dim { opacity:.35; color: var(--muted); }
    #status { font-family: ui-monospace, Menlo, Consolas, monospace; color: var(--muted); text-align:center; }
    #hint { font-size:.9rem; color:var(--muted); }
    /* we keep the video hidden; FaceDetector still reads from it */
    video { position:absolute; opacity:0; width:1px; height:1px; pointer-events:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Face Center Arrow</h1>

    <div class="row">
      <button id="start">Start</button>
      <button id="center">Re-center</button>
      <label>Dead-zone
        <input id="dead" type="range" min="1" max="20" value="6" />
        <span id="deadVal">6%</span>
      </label>
      <label>Smoothing
        <input id="smooth" type="range" min="0" max="95" value="70" />
        <span id="smoothVal">0.70</span>
      </label>
    </div>

    <div id="arrow" class="dim">⌖</div>
    <div id="status">ready.</div>
    <div id="hint">start → look at the phone → follow the arrow until “centered”.</div>

    <video id="video" autoplay playsinline muted></video>
  </div>

  <script>
    const video = document.getElementById('video');
    const startBtn = document.getElementById('start');
    const centerBtn = document.getElementById('center');
    const arrowEl = document.getElementById('arrow');
    const statusEl = document.getElementById('status');
    const deadInput = document.getElementById('dead');
    const deadVal = document.getElementById('deadVal');
    const smoothInput = document.getElementById('smooth');
    const smoothVal = document.getElementById('smoothVal');

    let detector = null;
    let neutral = 0;         // neutral offset (xNorm) after recentering
    let emaX = 0;            // smoothed x offset (-1..+1)
    let running = false;

    function log(s){ statusEl.textContent = s; }
    function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }

    deadInput.oninput = () => deadVal.textContent = deadInput.value + '%';
    smoothInput.oninput = () => smoothVal.textContent = (Number(smoothInput.value)/100).toFixed(2);

    centerBtn.onclick = () => { neutral = emaX; log('re-centered'); };

    startBtn.onclick = async () => {
      if (!('FaceDetector' in window)) {
        alert('FaceDetector API not available in this browser. Try Chrome/Edge. (I can add a TF.js fallback if you want.)');
        return;
      }
      try {
        // front camera; we hide the element, but it must be playing
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();

        detector = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
        running = true;
        requestAnimationFrame(loop);
        log('running…');
      } catch (e) {
        console.error(e);
        alert(e.message || e);
      }
    };

    function setArrow(dir/* -1 left, 0 center, +1 right */, strength/*0..1*/) {
      if (Math.abs(dir) < 0.01 && strength < 0.05) {
        arrowEl.textContent = '✔';          // centered
        arrowEl.classList.add('dim');
        arrowEl.style.transform = 'scale(1)';
        arrowEl.style.color = 'var(--ok)';
        log('centered');
        return;
      }
      arrowEl.classList.remove('dim');
      arrowEl.style.color = 'var(--fg)';
      // choose glyph
      arrowEl.textContent = dir < 0 ? '←' : '→';
      // scale with strength for an intuitive “how much”
      const s = 1 + 1.2 * clamp(strength, 0, 1);
      arrowEl.style.transform = `scale(${s})`;
      log((dir < 0 ? 'turn left ' : 'turn right ') + Math.round(strength * 100) + '%');
    }

    async function loop() {
      if (!running) return;

      try {
        const faces = await detector.detect(video);
        if (faces && faces.length) {
          const bb = faces[0].boundingBox;
          const cx = bb.x + bb.width/2;
          const w = video.videoWidth || 640;
          // normalize face center: left=-1, center=0, right=+1
          let xNorm = ((cx / w) - 0.5) * 2;

          // smoothing (EMA)
          const k = Number(smoothInput.value)/100; // 0..0.95
          emaX = (1 - k) * xNorm + k * emaX;

          // apply user neutral (recenter)
          const err = emaX - neutral;

          const dead = Number(deadInput.value) / 100; // dead-zone in normalized units
          const mag = Math.max(0, Math.abs(err) - dead) / (1 - dead); // 0..1 after dead-zone
          const dir = Math.sign(err);

          setArrow(dir, mag);
        } else {
          arrowEl.textContent = '⌖'; // aim/idle
          arrowEl.classList.add('dim');
          arrowEl.style.transform = 'scale(1)';
          arrowEl.style.color = 'var(--muted)';
          log('no face');
          // slowly relax toward center to avoid drift
          emaX *= 0.98;
        }
      } catch (e) {
        // ignore transient detector errors
      }
      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
