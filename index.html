<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gesture Gallery (Fixed Mobile)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      background: #000; 
      overflow: hidden;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    
    /* Only the image is visible */
    #ghost {
      position: absolute; 
      inset: 0; 
      margin: auto;
      max-width: 90vw; 
      max-height: 90vh; 
      object-fit: contain;
      transform: translate(0px, 0px) scale(1) translateZ(0);
      transition: transform 0.12s ease;
      user-select: none; 
      pointer-events: none;
      filter: drop-shadow(0 0 30px rgba(0,0,0,0.6));
      transform-origin: center center;
    }
    
    /* Hidden video for the recognizer - IMPORTANT: Set proper aspect ratio */
    #cam { 
      display: none;
      width: 640px;
      height: 480px;
      object-fit: cover;
    }
    
    /* One-tap starter */
    #tap {
      position: absolute; 
      inset: 0; 
      display: grid; 
      place-items: center;
      color: #888; 
      font: 600 14px system-ui; 
      background: transparent; 
      cursor: pointer;
      z-index: 1000;
    }
    #tap.hide { display: none; }

    /* Debug info */
    .debug {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font: 12px monospace;
      background: rgba(0,0,0,0.5);
      padding: 5px;
      border-radius: 3px;
      z-index: 999;
      display: none;
    }
    .debug.show { display: block; }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      #ghost {
        max-width: 95vw;
        max-height: 95vh;
      }
    }
  </style>
</head>
<body>
  <img id="ghost" alt="image" />
  <video id="cam" autoplay playsinline muted></video>
  <div id="tap">tap to start camera<br><small>(back camera preferred)</small></div>
  <div id="debug" class="debug">
    <div>Camera: <span id="camera-info">-</span></div>
    <div>Resolution: <span id="resolution-info">-</span></div>
    <div>Gesture: <span id="gesture-info">-</span></div>
  </div>

  <!-- MediaPipe Tasks Vision (GestureRecognizer) -->
  <script type="module">
    import {
      GestureRecognizer,
      FilesetResolver
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    // Public images that read well on black
    const IMAGES = [
      "https://upload.wikimedia.org/wikipedia/commons/9/97/The_Earth_seen_from_Apollo_17.jpg",
      "https://upload.wikimedia.org/wikipedia/commons/thumb/3/33/NGC2207%2BIC2163.jpg/640px-NGC2207%2BIC2163.jpg",
      "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Venus_colour.png/640px-Venus_colour.png",
      "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/NGC6543.jpg/640px-NGC6543.jpg",
      "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Crab_Nebula.jpg/640px-Crab_Nebula.jpg"
    ];

    const imgEl = document.getElementById('ghost');
    const videoEl = document.getElementById('cam');
    const tapEl = document.getElementById('tap');
    const debugEl = document.getElementById('debug');
    const cameraInfo = document.getElementById('camera-info');
    const resolutionInfo = document.getElementById('resolution-info');
    const gestureInfo = document.getElementById('gesture-info');

    // Enable debug mode with double tap
    let tapCount = 0;
    tapEl.addEventListener('click', () => {
      tapCount++;
      setTimeout(() => tapCount = 0, 300);
      if (tapCount === 2) {
        debugEl.classList.toggle('show');
      }
    });

    let idx = 0;

    // --- View transform state (scale + pan) ---
    let scale = 1;
    let tx = 0, ty = 0;
    const SCALE_MIN = 0.4, SCALE_MAX = 2.8, SCALE_STEP = 0.02;
    const DRAG_SENSITIVITY = 1.2;

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function applyTransform(){
      imgEl.style.transform = `translate(${tx}px, ${ty}px) scale(${scale}) translateZ(0)`;
    }
    function setScale(s){ scale = clamp(s, SCALE_MIN, SCALE_MAX); applyTransform(); }

    function clampPan(){
      const pad = 200;
      const maxX = (window.innerWidth/2) + pad;
      const minX = -maxX;
      const maxY = (window.innerHeight/2) + pad;
      const minY = -maxY;
      tx = clamp(tx, minX, maxX);
      ty = clamp(ty, minY, maxY);
    }

    function showImage(i, depth=0){
      if (depth > IMAGES.length) return;
      const safe = ((i % IMAGES.length) + IMAGES.length) % IMAGES.length;
      idx = safe;
      const probe = new Image();
      probe.onload  = () => { imgEl.src = IMAGES[idx]; };
      probe.onerror = () => { showImage(idx + 1, depth + 1); };
      probe.src = IMAGES[idx];
    }
    showImage(idx);
    setScale(1);

    let lastPointAt = 0;
    const POINT_COOLDOWN_MS = 700;

    // --- Drag tracking ---
    let lastDrag = null;

    function startDragAt(px, py){
      lastDrag = { x: px, y: py };
    }
    
    function updateDrag(px, py){
      if (!lastDrag) { startDragAt(px, py); return; }
      const dx = (px - lastDrag.x) * DRAG_SENSITIVITY;
      const dy = (py - lastDrag.y) * DRAG_SENSITIVITY;
      tx += dx; ty += dy;
      clampPan();
      applyTransform();
      lastDrag = { x: px, y: py };
    }
    
    function endDrag(){ lastDrag = null; }

    function handleGesture(label, landmarks){
      gestureInfo.textContent = label;
      
      if (label === "Open_Palm") {
        setScale(scale + SCALE_STEP);
        endDrag();
      } else if (label === "Closed_Fist") {
        setScale(scale - SCALE_STEP);
        endDrag();
      } else if (label === "Thumb_Up") {
        const now = performance.now();
        if (now - lastPointAt > POINT_COOLDOWN_MS) {
          lastPointAt = now;
          showImage(idx + 1);
        }
        endDrag();
      } else if (label === "Pointing_Up") {
        if (landmarks && landmarks.length > 0 && landmarks[0] && landmarks[0][8]) {
          const tip = landmarks[0][8];
          // IMPORTANT: Account for camera mirroring and aspect ratio
          const px = (1 - tip.x) * window.innerWidth; // Mirror X coordinate
          const py = tip.y * window.innerHeight;
          updateDrag(px, py);
        }
      } else {
        endDrag();
      }
    }

    // Improved camera initialization
    async function initCamera() {
      try {
        // Try to get back camera first
        let stream;
        
        // Mobile device detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (isMobile) {
          // On mobile, try back camera with specific constraints
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: { exact: 'environment' },
                width: { ideal: 640, min: 480 },
                height: { ideal: 480, min: 360 },
                aspectRatio: { ideal: 4/3 }
              }
            });
            cameraInfo.textContent = 'Back camera (mobile)';
          } catch (e) {
            console.warn('Back camera not available, trying front:', e);
            // Fallback to front camera
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: 'user',
                width: { ideal: 640, min: 480 },
                height: { ideal: 480, min: 360 },
                aspectRatio: { ideal: 4/3 }
              }
            });
            cameraInfo.textContent = 'Front camera (mobile)';
          }
        } else {
          // Desktop - try back camera first, then any camera
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: { ideal: 'environment' },
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            });
            cameraInfo.textContent = 'Back camera (desktop)';
          } catch (e) {
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 }
              }
            });
            cameraInfo.textContent = 'Default camera (desktop)';
          }
        }

        videoEl.srcObject = stream;
        
        // Wait for video to load and get actual dimensions
        return new Promise((resolve, reject) => {
          videoEl.onloadedmetadata = () => {
            // Set video element dimensions to match stream
            const track = stream.getVideoTracks()[0];
            const settings = track.getSettings();
            
            resolutionInfo.textContent = `${settings.width}x${settings.height}`;
            
            // Important: Set video element size to match stream aspect ratio
            if (settings.width && settings.height) {
              const aspectRatio = settings.width / settings.height;
              videoEl.style.width = '640px';
              videoEl.style.height = (640 / aspectRatio) + 'px';
            }
            
            videoEl.play().then(resolve).catch(reject);
          };
          videoEl.onerror = reject;
        });
        
      } catch (error) {
        console.error('Camera initialization failed:', error);
        cameraInfo.textContent = 'Camera failed';
        throw error;
      }
    }

    let started = false;
    async function start(){
      if (started) return; 
      started = true;
      tapEl.classList.add('hide');

      try {
        await initCamera();

        // Load WASM core and the gesture model
        const fileset = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
        );
        
        const recognizer = await GestureRecognizer.createFromOptions(fileset, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task"
          },
          runningMode: "VIDEO",
          numHands: 1
        });

        // Video loop with error handling
        let lastTime = 0;
        const loop = (currentTime) => {
          try {
            // Throttle to ~30fps for better performance on mobile
            if (currentTime - lastTime >= 33) {
              const result = recognizer.recognizeForVideo(videoEl, currentTime);
              
              if (result && result.gestures && result.gestures.length > 0) {
                const top = result.gestures[0][0];
                if (top && top.categoryName && top.score > 0.6) {
                  handleGesture(top.categoryName, result.landmarks);
                } else {
                  gestureInfo.textContent = 'Low confidence';
                  endDrag();
                }
              } else {
                gestureInfo.textContent = 'No gesture';
                endDrag();
              }
              
              lastTime = currentTime;
            }
          } catch (error) {
            console.error('Recognition error:', error);
          }
          
          requestAnimationFrame(loop);
        };
        
        requestAnimationFrame(loop);
        
      } catch (error) {
        console.error('Startup failed:', error);
        tapEl.textContent = 'Camera access failed. Please refresh and allow camera.';
        tapEl.classList.remove('hide');
        started = false;
      }
    }

    // Event listeners
    tapEl.addEventListener('click', start);
    imgEl.addEventListener('click', start);
    
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'ArrowRight') showImage(idx + 1);
      if (e.key === '+') setScale(scale + 0.05);
      if (e.key === '-') setScale(scale - 0.05);
      if (e.key === 'd') debugEl.classList.toggle('show');
      start();
    });

    window.addEventListener('resize', () => { 
      clampPan(); 
      applyTransform(); 
    });

    // Handle visibility changes (pause/resume when tab becomes hidden/visible)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // Tab is hidden - could pause processing here
      } else {
        // Tab is visible again
      }
    });

  </script>
</body>
</html>
