<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Earth – Pinch Distance = Zoom (No Drag)</title>
<style>
  html,body {height:100%}
  body {margin:0; background:#000; color:#eee; font-family:system-ui, sans-serif}
  #view {width:100vw; height:100vh; display:block; background:#000}
  #cam {display:none}
  #tap {position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000}
  button {font-size:1rem; padding:.6rem 1rem}
  .hint {position:fixed; left:12px; bottom:12px; opacity:.8; font-size:14px}
</style>
</head>
<body>
<canvas id="view"></canvas>
<video id="cam" playsinline muted></video>
<div id="tap"><button id="startBtn">Start Camera</button></div>
<div class="hint">Thumb–Index distance = zoom • R = reset</div>

<script type="module">
import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d', { alpha:false });
const cam = document.getElementById('cam');
const overlay = document.getElementById('tap');
const btn = document.getElementById('startBtn');

// 🌍 Earth image
const img = new Image();
img.crossOrigin = "anonymous";
img.src = "https://upload.wikimedia.org/wikipedia/commons/9/97/The_Earth_seen_from_Apollo_17.jpg";
await img.decode();

// --- State (center stays fixed) ---
let cx = 0, cy = 0;           // canvas center
let scale = 0.8, targetScale = 0.8;
const EASE = 0.25;

// Map pinch distance -> scale
// d ≈ 0.00 (touching) … ~0.20 (far apart) depending on camera framing
const MIN_SCALE = 0.05;       // size when fingers are touching
const MAX_SCALE = 2;        // size when fingers are far apart
const DIST_MIN  = 0.00;       // distance mapped to MIN_SCALE
const DIST_MAX  = 2.0;       // distance mapped to MAX_SCALE (tweak for your setup)

let lastVideoTime = -1;

// --- Resize ---
function resize(){
  const dpr = Math.min(window.devicePixelRatio||1, 2);
  canvas.width  = Math.floor(innerWidth  * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  cx = canvas.width/2;
  cy = canvas.height/2;
}
window.addEventListener('resize', resize); resize();

// --- MediaPipe Hands ---
const files = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
const hands = await HandLandmarker.createFromOptions(files, {
  baseOptions:{ modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
  runningMode:"VIDEO",
  numHands:1
});

// --- Camera ---
async function startCam(){
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:{ideal:"environment"}, width:{ideal:640}, height:{ideal:480}, frameRate:{ideal:30, max:30} },
    audio:false
  });
  cam.srcObject = stream;
  await cam.play();
  loop();
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// --- Main loop ---
function loop(){
  requestAnimationFrame(loop);

  // black bg
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // ease scale
  scale += (targetScale - scale) * EASE;

  // draw earth centered
  ctx.save();
  ctx.translate(cx, cy);
  ctx.scale(scale, scale);
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(img, -img.width/2, -img.height/2);
  ctx.restore();

  // run hand tracking once per video frame
  if (!cam.videoWidth) return;
  const vt = cam.currentTime;
  if (vt === lastVideoTime) return;
  lastVideoTime = vt;

  const res = hands.detectForVideo(cam, performance.now());
  if (!res?.landmarks?.length) return;

  // distance between index tip (8) and thumb tip (4)
  const lm = res.landmarks[0];
  const d = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);

  // map distance -> target scale, linearly
  const t = clamp((d - DIST_MIN) / (DIST_MAX - DIST_MIN), 0, 1);
  targetScale = MIN_SCALE + t * (MAX_SCALE - MIN_SCALE);
}

// --- Reset ---
window.addEventListener('keydown', e=>{
  if (e.key.toLowerCase() === 'r') {
    targetScale = 0.8;
  }
});

// --- Go ---
btn.addEventListener('click', async ()=>{
  try { await startCam(); overlay.style.display='none'; }
  catch(e){ alert('Camera failed: '+e.message); console.error(e); }
});
</script>
</body>
</html>
